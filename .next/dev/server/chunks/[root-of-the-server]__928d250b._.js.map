{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 64, "column": 0}, "map": {"version":3,"sources":["file:///Users/yangguanghua/Desktop/agnet-web/lib/logs.ts"],"sourcesContent":["import fs from 'fs/promises';\nimport path from 'path';\nimport os from 'os';\nimport type { LogItem, LogsResponse, SessionInfo } from '@/types/logs';\n\nconst MAX_SESSION_LINES = 2000;\nconst MAX_HISTORY_LINES = 400;\n\nconst ROLE_SET = new Set(['user', 'assistant', 'developer', 'system', 'tool']);\n\ntype UnknownRecord = Record<string, unknown>;\n\nconst isObject = (value: unknown): value is UnknownRecord =>\n  typeof value === 'object' && value !== null;\n\nconst toNumberTimestamp = (value: unknown): number | null => {\n  if (typeof value === 'number' && Number.isFinite(value)) {\n    return value < 1e12 ? value * 1000 : value;\n  }\n  if (typeof value === 'string') {\n    const parsed = Date.parse(value);\n    if (!Number.isNaN(parsed)) return parsed;\n  }\n  return null;\n};\n\nconst extractTimestamp = (data: UnknownRecord): number | null => {\n  const candidates = [\n    data.ts,\n    data.timestamp,\n    data.time,\n    data.created_at,\n    data.createdAt,\n  ];\n  for (const candidate of candidates) {\n    const parsed = toNumberTimestamp(candidate);\n    if (parsed) return parsed;\n  }\n  return null;\n};\n\nconst extractRole = (data: UnknownRecord): LogItem['role'] | null => {\n  const raw = data.role ?? data.author ?? data.actor;\n  if (typeof raw === 'string' && ROLE_SET.has(raw)) {\n    return raw as LogItem['role'];\n  }\n  return null;\n};\n\nconst extractTextFromContent = (content: unknown): string | null => {\n  if (typeof content === 'string') return content;\n  if (!content) return null;\n  if (Array.isArray(content)) {\n    const parts = content\n      .map((part) => {\n        if (typeof part === 'string') return part;\n        if (isObject(part)) {\n          const text = part.text ?? part.value ?? part.content;\n          return typeof text === 'string' ? text : null;\n        }\n        return null;\n      })\n      .filter(Boolean);\n    return parts.length ? parts.join('\\n') : null;\n  }\n  if (isObject(content)) {\n    const text = content.text ?? content.value ?? content.content;\n    if (typeof text === 'string') return text;\n  }\n  return null;\n};\n\nconst extractText = (data: UnknownRecord): string | null => {\n  const direct = data.text ?? data.message ?? data.prompt;\n  if (typeof direct === 'string') return direct;\n  const content = data.content ?? data.output ?? data.response;\n  return extractTextFromContent(content);\n};\n\nconst extractSessionMeta = (data: UnknownRecord) => {\n  const type = data.type ?? data.event ?? data.object;\n  if (type !== 'session_meta') return null;\n  const id =\n    (typeof data.id === 'string' && data.id) ||\n    (typeof data.session_id === 'string' && data.session_id) ||\n    (typeof data.sessionId === 'string' && data.sessionId) ||\n    null;\n  const parentId =\n    (typeof data.parent_id === 'string' && data.parent_id) ||\n    (typeof data.parent_session_id === 'string' && data.parent_session_id) ||\n    (typeof data.parentId === 'string' && data.parentId) ||\n    null;\n  return { id, parentId };\n};\n\nconst extractLogFields = (\n  data: UnknownRecord,\n): { role: LogItem['role']; text: string; ts: number | null } | null => {\n  const role = extractRole(data);\n  const text = extractText(data);\n  if (role && text) {\n    return { role, text, ts: extractTimestamp(data) };\n  }\n\n  const nested = [data.message, data.item, data.output, data.response];\n  for (const entry of nested) {\n    if (Array.isArray(entry)) {\n      for (const child of entry) {\n        if (isObject(child)) {\n          const result = extractLogFields(child);\n          if (result) return result;\n        }\n      }\n    } else if (isObject(entry)) {\n      const result = extractLogFields(entry);\n      if (result) return result;\n    }\n  }\n\n  return null;\n};\n\nconst safeParse = (line: string): UnknownRecord | null => {\n  try {\n    const parsed = JSON.parse(line) as unknown;\n    if (isObject(parsed)) return parsed;\n  } catch {\n    return null;\n  }\n  return null;\n};\n\nconst getFileMtimeMs = async (filePath: string): Promise<number | null> => {\n  try {\n    const stat = await fs.stat(filePath);\n    return stat.mtimeMs;\n  } catch {\n    return null;\n  }\n};\n\nexport const getCodexRoot = () => path.join(os.homedir(), '.codex');\n\nexport const collectSessionFiles = async (root: string): Promise<string[]> => {\n  const sessionRoot = path.join(root, 'sessions');\n  const results: string[] = [];\n\n  const walk = async (dir: string) => {\n    let entries;\n    try {\n      entries = await fs.readdir(dir, { withFileTypes: true });\n    } catch {\n      return;\n    }\n\n    await Promise.all(\n      entries.map(async (entry) => {\n        const fullPath = path.join(dir, entry.name);\n        if (entry.isDirectory()) {\n          await walk(fullPath);\n          return;\n        }\n        if (entry.isFile() && fullPath.endsWith('.jsonl')) {\n          results.push(fullPath);\n        }\n      }),\n    );\n  };\n\n  await walk(sessionRoot);\n  return results;\n};\n\nexport const readJsonl = async (\n  filePath: string,\n  maxLines?: number,\n): Promise<string[]> => {\n  try {\n    const content = await fs.readFile(filePath, 'utf8');\n    const lines = content.split(/\\r?\\n/).filter(Boolean);\n    if (maxLines && lines.length > maxLines) {\n      return lines.slice(-maxLines);\n    }\n    return lines;\n  } catch {\n    return [];\n  }\n};\n\nexport const parseSessionFile = async (filePath: string) => {\n  const lines = await readJsonl(filePath, MAX_SESSION_LINES);\n  const fileMtimeMs = await getFileMtimeMs(filePath);\n  const fallbackBaseTs = fileMtimeMs ?? Date.now();\n  let sessionId: string | null = null;\n  let parentId: string | null = null;\n  let lastUserText: string | undefined;\n  let lastTs: number | undefined;\n\n  const logs: LogItem[] = [];\n\n  const totalLines = lines.length;\n  lines.forEach((line, index) => {\n    const data = safeParse(line);\n    if (!data) return;\n\n    const meta = extractSessionMeta(data);\n    if (meta) {\n      if (meta.id) sessionId = meta.id;\n      if (meta.parentId) parentId = meta.parentId;\n    }\n\n    const logFields = extractLogFields(data);\n    if (logFields) {\n      const ts =\n        logFields.ts ??\n        Math.max(0, fallbackBaseTs - (totalLines - index));\n      const item: LogItem = {\n        id: `${sessionId ?? 'session'}-${index}-${ts}`,\n        ts,\n        iso: new Date(ts).toISOString(),\n        source: 'session',\n        sessionId: sessionId ?? undefined,\n        role: logFields.role,\n        text: logFields.text,\n      };\n      logs.push(item);\n      if (logFields.role === 'user') {\n        lastUserText = logFields.text;\n      }\n      if (!lastTs || ts > lastTs) {\n        lastTs = ts;\n      }\n    }\n  });\n\n  if (!sessionId) {\n    sessionId = path.basename(filePath, path.extname(filePath));\n  }\n\n  if (!lastTs && fileMtimeMs) {\n    lastTs = fileMtimeMs;\n  }\n\n  const session: SessionInfo | null = sessionId\n    ? {\n        id: sessionId,\n        kind: parentId ? 'subagent' : 'main',\n        parentId: parentId ?? undefined,\n        lastUserText,\n        lastTs,\n      }\n    : null;\n\n  return { session, logs };\n};\n\nexport const parseHistoryFile = async (\n  filePath: string,\n  maxLines: number,\n): Promise<LogItem[]> => {\n  const lines = await readJsonl(filePath, maxLines);\n  const fileMtimeMs = await getFileMtimeMs(filePath);\n  const fallbackBaseTs = fileMtimeMs ?? Date.now();\n  const totalLines = lines.length;\n  const logs: LogItem[] = [];\n\n  lines.forEach((line, index) => {\n    const data = safeParse(line);\n    if (!data) return;\n\n    const logFields = extractLogFields(data);\n    if (!logFields) return;\n\n    const ts =\n      logFields.ts ?? Math.max(0, fallbackBaseTs - (totalLines - index));\n    logs.push({\n      id: `history-${index}-${ts}`,\n      ts,\n      iso: new Date(ts).toISOString(),\n      source: 'history',\n      role: logFields.role,\n      text: logFields.text,\n    });\n  });\n\n  return logs;\n};\n\nexport const buildLogsResponse = async (\n  maxItems = 50,\n  maxPigs = 30,\n): Promise<LogsResponse> => {\n  const root = getCodexRoot();\n  const historyPath = path.join(root, 'history.jsonl');\n\n  const sessionFilesPromise = collectSessionFiles(root);\n  const historyPromise = parseHistoryFile(historyPath, MAX_HISTORY_LINES);\n\n  const sessionFiles = await sessionFilesPromise;\n  const sessionResults = await Promise.all(\n    sessionFiles.map((filePath) => parseSessionFile(filePath)),\n  );\n\n  const sessions = sessionResults\n    .map((result) => result.session)\n    .filter(Boolean) as SessionInfo[];\n\n  sessions.sort((a, b) => (b.lastTs ?? 0) - (a.lastTs ?? 0));\n\n  const sessionLogs = sessionResults.flatMap((result) => result.logs);\n  const historyLogs = await historyPromise;\n\n  const items = [...sessionLogs, ...historyLogs]\n    .sort((a, b) => b.ts - a.ts)\n    .slice(0, maxItems);\n\n  return {\n    updatedAt: new Date().toISOString(),\n    items,\n    sessions: sessions.slice(0, maxPigs),\n  };\n};\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 353, "column": 0}, "map": {"version":3,"sources":["file:///Users/yangguanghua/Desktop/agnet-web/app/api/logs/route.ts"],"sourcesContent":["import { NextResponse } from 'next/server';\nimport { buildLogsResponse } from '@/lib/logs';\n\nexport const dynamic = 'force-dynamic';\nexport const runtime = 'nodejs';\n\nexport async function GET() {\n  try {\n    const data = await buildLogsResponse();\n    return NextResponse.json(data, {\n      headers: {\n        'Cache-Control': 'no-store',\n      },\n    });\n  } catch {\n    return NextResponse.json(\n      {\n        updatedAt: new Date().toISOString(),\n        items: [],\n        sessions: [],\n      },\n      {\n        headers: {\n          'Cache-Control': 'no-store',\n        },\n      },\n    );\n  }\n}\n"],"names":[],"mappings":";;;;;;;;AAAA;AACA;;;AAEO,MAAM,UAAU;AAChB,MAAM,UAAU;AAEhB,eAAe;IACpB,IAAI;QACF,MAAM,OAAO,MAAM,IAAA,kIAAiB;QACpC,OAAO,qWAAY,CAAC,IAAI,CAAC,MAAM;YAC7B,SAAS;gBACP,iBAAiB;YACnB;QACF;IACF,EAAE,OAAM;QACN,OAAO,qWAAY,CAAC,IAAI,CACtB;YACE,WAAW,IAAI,OAAO,WAAW;YACjC,OAAO,EAAE;YACT,UAAU,EAAE;QACd,GACA;YACE,SAAS;gBACP,iBAAiB;YACnB;QACF;IAEJ;AACF"}}]
}